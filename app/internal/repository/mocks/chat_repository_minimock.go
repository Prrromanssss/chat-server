// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Prrromanssss/chat-server/internal/repository.ChatRepository -o chat_repository_minimock.go -n ChatRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Prrromanssss/chat-server/internal/model"
	"github.com/gojuno/minimock/v3"
)

// ChatRepositoryMock implements repository.ChatRepository
type ChatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAPILog          func(ctx context.Context, params model.CreateAPILogParams) (err error)
	inspectFuncCreateAPILog   func(ctx context.Context, params model.CreateAPILogParams)
	afterCreateAPILogCounter  uint64
	beforeCreateAPILogCounter uint64
	CreateAPILogMock          mChatRepositoryMockCreateAPILog

	funcCreateChat          func(ctx context.Context) (resp model.CreateChatResponse, err error)
	inspectFuncCreateChat   func(ctx context.Context)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatRepositoryMockCreateChat

	funcCreateUsersForChat          func(ctx context.Context, params model.CreateUsersForChatParams) (resp model.CreateUsersForChatResponse, err error)
	inspectFuncCreateUsersForChat   func(ctx context.Context, params model.CreateUsersForChatParams)
	afterCreateUsersForChatCounter  uint64
	beforeCreateUsersForChatCounter uint64
	CreateUsersForChatMock          mChatRepositoryMockCreateUsersForChat

	funcDeleteChat          func(ctx context.Context, params model.DeleteChatParams) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, params model.DeleteChatParams)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatRepositoryMockDeleteChat

	funcLinkParticipantsToChat          func(ctx context.Context, params model.LinkParticipantsToChatParams) (err error)
	inspectFuncLinkParticipantsToChat   func(ctx context.Context, params model.LinkParticipantsToChatParams)
	afterLinkParticipantsToChatCounter  uint64
	beforeLinkParticipantsToChatCounter uint64
	LinkParticipantsToChatMock          mChatRepositoryMockLinkParticipantsToChat

	funcSendMessage          func(ctx context.Context, params model.SendMessageParams) (err error)
	inspectFuncSendMessage   func(ctx context.Context, params model.SendMessageParams)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatRepositoryMockSendMessage

	funcUnlinkParticipantsFromChat          func(ctx context.Context, params model.UnlinkParticipantsFromChatParams) (err error)
	inspectFuncUnlinkParticipantsFromChat   func(ctx context.Context, params model.UnlinkParticipantsFromChatParams)
	afterUnlinkParticipantsFromChatCounter  uint64
	beforeUnlinkParticipantsFromChatCounter uint64
	UnlinkParticipantsFromChatMock          mChatRepositoryMockUnlinkParticipantsFromChat
}

// NewChatRepositoryMock returns a mock for repository.ChatRepository
func NewChatRepositoryMock(t minimock.Tester) *ChatRepositoryMock {
	m := &ChatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAPILogMock = mChatRepositoryMockCreateAPILog{mock: m}
	m.CreateAPILogMock.callArgs = []*ChatRepositoryMockCreateAPILogParams{}

	m.CreateChatMock = mChatRepositoryMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatRepositoryMockCreateChatParams{}

	m.CreateUsersForChatMock = mChatRepositoryMockCreateUsersForChat{mock: m}
	m.CreateUsersForChatMock.callArgs = []*ChatRepositoryMockCreateUsersForChatParams{}

	m.DeleteChatMock = mChatRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatRepositoryMockDeleteChatParams{}

	m.LinkParticipantsToChatMock = mChatRepositoryMockLinkParticipantsToChat{mock: m}
	m.LinkParticipantsToChatMock.callArgs = []*ChatRepositoryMockLinkParticipantsToChatParams{}

	m.SendMessageMock = mChatRepositoryMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatRepositoryMockSendMessageParams{}

	m.UnlinkParticipantsFromChatMock = mChatRepositoryMockUnlinkParticipantsFromChat{mock: m}
	m.UnlinkParticipantsFromChatMock.callArgs = []*ChatRepositoryMockUnlinkParticipantsFromChatParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryMockCreateAPILog struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateAPILogExpectation
	expectations       []*ChatRepositoryMockCreateAPILogExpectation

	callArgs []*ChatRepositoryMockCreateAPILogParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockCreateAPILogExpectation specifies expectation struct of the ChatRepository.CreateAPILog
type ChatRepositoryMockCreateAPILogExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockCreateAPILogParams
	paramPtrs *ChatRepositoryMockCreateAPILogParamPtrs
	results   *ChatRepositoryMockCreateAPILogResults
	Counter   uint64
}

// ChatRepositoryMockCreateAPILogParams contains parameters of the ChatRepository.CreateAPILog
type ChatRepositoryMockCreateAPILogParams struct {
	ctx    context.Context
	params model.CreateAPILogParams
}

// ChatRepositoryMockCreateAPILogParamPtrs contains pointers to parameters of the ChatRepository.CreateAPILog
type ChatRepositoryMockCreateAPILogParamPtrs struct {
	ctx    *context.Context
	params *model.CreateAPILogParams
}

// ChatRepositoryMockCreateAPILogResults contains results of the ChatRepository.CreateAPILog
type ChatRepositoryMockCreateAPILogResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) Optional() *mChatRepositoryMockCreateAPILog {
	mmCreateAPILog.optional = true
	return mmCreateAPILog
}

// Expect sets up expected params for ChatRepository.CreateAPILog
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) Expect(ctx context.Context, params model.CreateAPILogParams) *mChatRepositoryMockCreateAPILog {
	if mmCreateAPILog.mock.funcCreateAPILog != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by Set")
	}

	if mmCreateAPILog.defaultExpectation == nil {
		mmCreateAPILog.defaultExpectation = &ChatRepositoryMockCreateAPILogExpectation{}
	}

	if mmCreateAPILog.defaultExpectation.paramPtrs != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by ExpectParams functions")
	}

	mmCreateAPILog.defaultExpectation.params = &ChatRepositoryMockCreateAPILogParams{ctx, params}
	for _, e := range mmCreateAPILog.expectations {
		if minimock.Equal(e.params, mmCreateAPILog.defaultExpectation.params) {
			mmCreateAPILog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAPILog.defaultExpectation.params)
		}
	}

	return mmCreateAPILog
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateAPILog
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateAPILog {
	if mmCreateAPILog.mock.funcCreateAPILog != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by Set")
	}

	if mmCreateAPILog.defaultExpectation == nil {
		mmCreateAPILog.defaultExpectation = &ChatRepositoryMockCreateAPILogExpectation{}
	}

	if mmCreateAPILog.defaultExpectation.params != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by Expect")
	}

	if mmCreateAPILog.defaultExpectation.paramPtrs == nil {
		mmCreateAPILog.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateAPILogParamPtrs{}
	}
	mmCreateAPILog.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateAPILog
}

// ExpectParamsParam2 sets up expected param params for ChatRepository.CreateAPILog
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) ExpectParamsParam2(params model.CreateAPILogParams) *mChatRepositoryMockCreateAPILog {
	if mmCreateAPILog.mock.funcCreateAPILog != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by Set")
	}

	if mmCreateAPILog.defaultExpectation == nil {
		mmCreateAPILog.defaultExpectation = &ChatRepositoryMockCreateAPILogExpectation{}
	}

	if mmCreateAPILog.defaultExpectation.params != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by Expect")
	}

	if mmCreateAPILog.defaultExpectation.paramPtrs == nil {
		mmCreateAPILog.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateAPILogParamPtrs{}
	}
	mmCreateAPILog.defaultExpectation.paramPtrs.params = &params

	return mmCreateAPILog
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateAPILog
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) Inspect(f func(ctx context.Context, params model.CreateAPILogParams)) *mChatRepositoryMockCreateAPILog {
	if mmCreateAPILog.mock.inspectFuncCreateAPILog != nil {
		mmCreateAPILog.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateAPILog")
	}

	mmCreateAPILog.mock.inspectFuncCreateAPILog = f

	return mmCreateAPILog
}

// Return sets up results that will be returned by ChatRepository.CreateAPILog
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) Return(err error) *ChatRepositoryMock {
	if mmCreateAPILog.mock.funcCreateAPILog != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by Set")
	}

	if mmCreateAPILog.defaultExpectation == nil {
		mmCreateAPILog.defaultExpectation = &ChatRepositoryMockCreateAPILogExpectation{mock: mmCreateAPILog.mock}
	}
	mmCreateAPILog.defaultExpectation.results = &ChatRepositoryMockCreateAPILogResults{err}
	return mmCreateAPILog.mock
}

// Set uses given function f to mock the ChatRepository.CreateAPILog method
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) Set(f func(ctx context.Context, params model.CreateAPILogParams) (err error)) *ChatRepositoryMock {
	if mmCreateAPILog.defaultExpectation != nil {
		mmCreateAPILog.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateAPILog method")
	}

	if len(mmCreateAPILog.expectations) > 0 {
		mmCreateAPILog.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateAPILog method")
	}

	mmCreateAPILog.mock.funcCreateAPILog = f
	return mmCreateAPILog.mock
}

// When sets expectation for the ChatRepository.CreateAPILog which will trigger the result defined by the following
// Then helper
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) When(ctx context.Context, params model.CreateAPILogParams) *ChatRepositoryMockCreateAPILogExpectation {
	if mmCreateAPILog.mock.funcCreateAPILog != nil {
		mmCreateAPILog.mock.t.Fatalf("ChatRepositoryMock.CreateAPILog mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateAPILogExpectation{
		mock:   mmCreateAPILog.mock,
		params: &ChatRepositoryMockCreateAPILogParams{ctx, params},
	}
	mmCreateAPILog.expectations = append(mmCreateAPILog.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateAPILog return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateAPILogExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateAPILogResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateAPILog should be invoked
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) Times(n uint64) *mChatRepositoryMockCreateAPILog {
	if n == 0 {
		mmCreateAPILog.mock.t.Fatalf("Times of ChatRepositoryMock.CreateAPILog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAPILog.expectedInvocations, n)
	return mmCreateAPILog
}

func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) invocationsDone() bool {
	if len(mmCreateAPILog.expectations) == 0 && mmCreateAPILog.defaultExpectation == nil && mmCreateAPILog.mock.funcCreateAPILog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAPILog.mock.afterCreateAPILogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAPILog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAPILog implements repository.ChatRepository
func (mmCreateAPILog *ChatRepositoryMock) CreateAPILog(ctx context.Context, params model.CreateAPILogParams) (err error) {
	mm_atomic.AddUint64(&mmCreateAPILog.beforeCreateAPILogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAPILog.afterCreateAPILogCounter, 1)

	if mmCreateAPILog.inspectFuncCreateAPILog != nil {
		mmCreateAPILog.inspectFuncCreateAPILog(ctx, params)
	}

	mm_params := ChatRepositoryMockCreateAPILogParams{ctx, params}

	// Record call args
	mmCreateAPILog.CreateAPILogMock.mutex.Lock()
	mmCreateAPILog.CreateAPILogMock.callArgs = append(mmCreateAPILog.CreateAPILogMock.callArgs, &mm_params)
	mmCreateAPILog.CreateAPILogMock.mutex.Unlock()

	for _, e := range mmCreateAPILog.CreateAPILogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateAPILog.CreateAPILogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAPILog.CreateAPILogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAPILog.CreateAPILogMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAPILog.CreateAPILogMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateAPILogParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAPILog.t.Errorf("ChatRepositoryMock.CreateAPILog got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmCreateAPILog.t.Errorf("ChatRepositoryMock.CreateAPILog got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAPILog.t.Errorf("ChatRepositoryMock.CreateAPILog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAPILog.CreateAPILogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAPILog.t.Fatal("No results are set for the ChatRepositoryMock.CreateAPILog")
		}
		return (*mm_results).err
	}
	if mmCreateAPILog.funcCreateAPILog != nil {
		return mmCreateAPILog.funcCreateAPILog(ctx, params)
	}
	mmCreateAPILog.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateAPILog. %v %v", ctx, params)
	return
}

// CreateAPILogAfterCounter returns a count of finished ChatRepositoryMock.CreateAPILog invocations
func (mmCreateAPILog *ChatRepositoryMock) CreateAPILogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAPILog.afterCreateAPILogCounter)
}

// CreateAPILogBeforeCounter returns a count of ChatRepositoryMock.CreateAPILog invocations
func (mmCreateAPILog *ChatRepositoryMock) CreateAPILogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAPILog.beforeCreateAPILogCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateAPILog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAPILog *mChatRepositoryMockCreateAPILog) Calls() []*ChatRepositoryMockCreateAPILogParams {
	mmCreateAPILog.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateAPILogParams, len(mmCreateAPILog.callArgs))
	copy(argCopy, mmCreateAPILog.callArgs)

	mmCreateAPILog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAPILogDone returns true if the count of the CreateAPILog invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateAPILogDone() bool {
	if m.CreateAPILogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAPILogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAPILogMock.invocationsDone()
}

// MinimockCreateAPILogInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateAPILogInspect() {
	for _, e := range m.CreateAPILogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateAPILog with params: %#v", *e.params)
		}
	}

	afterCreateAPILogCounter := mm_atomic.LoadUint64(&m.afterCreateAPILogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAPILogMock.defaultExpectation != nil && afterCreateAPILogCounter < 1 {
		if m.CreateAPILogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateAPILog")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateAPILog with params: %#v", *m.CreateAPILogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAPILog != nil && afterCreateAPILogCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateAPILog")
	}

	if !m.CreateAPILogMock.invocationsDone() && afterCreateAPILogCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateAPILog but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAPILogMock.expectedInvocations), afterCreateAPILogCounter)
	}
}

type mChatRepositoryMockCreateChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateChatExpectation
	expectations       []*ChatRepositoryMockCreateChatExpectation

	callArgs []*ChatRepositoryMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockCreateChatExpectation specifies expectation struct of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockCreateChatParams
	paramPtrs *ChatRepositoryMockCreateChatParamPtrs
	results   *ChatRepositoryMockCreateChatResults
	Counter   uint64
}

// ChatRepositoryMockCreateChatParams contains parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParams struct {
	ctx context.Context
}

// ChatRepositoryMockCreateChatParamPtrs contains pointers to parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParamPtrs struct {
	ctx *context.Context
}

// ChatRepositoryMockCreateChatResults contains results of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatResults struct {
	resp model.CreateChatResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatRepositoryMockCreateChat) Optional() *mChatRepositoryMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Expect(ctx context.Context) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatRepositoryMockCreateChatParams{ctx}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Inspect(f func(ctx context.Context)) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Return(resp model.CreateChatResponse, err error) *ChatRepositoryMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatRepositoryMockCreateChatResults{resp, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatRepository.CreateChat method
func (mmCreateChat *mChatRepositoryMockCreateChat) Set(f func(ctx context.Context) (resp model.CreateChatResponse, err error)) *ChatRepositoryMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatRepository.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepositoryMockCreateChat) When(ctx context.Context) *ChatRepositoryMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatRepositoryMockCreateChatParams{ctx},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateChatExpectation) Then(resp model.CreateChatResponse, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateChatResults{resp, err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateChat should be invoked
func (mmCreateChat *mChatRepositoryMockCreateChat) Times(n uint64) *mChatRepositoryMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatRepositoryMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	return mmCreateChat
}

func (mmCreateChat *mChatRepositoryMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements repository.ChatRepository
func (mmCreateChat *ChatRepositoryMock) CreateChat(ctx context.Context) (resp model.CreateChatResponse, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx)
	}

	mm_params := ChatRepositoryMockCreateChatParams{ctx}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateChatParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatRepositoryMock.CreateChat")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateChat. %v", ctx)
	return
}

// CreateChatAfterCounter returns a count of finished ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepositoryMockCreateChat) Calls() []*ChatRepositoryMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat with params: %#v", *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateChat")
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateChat but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), afterCreateChatCounter)
	}
}

type mChatRepositoryMockCreateUsersForChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateUsersForChatExpectation
	expectations       []*ChatRepositoryMockCreateUsersForChatExpectation

	callArgs []*ChatRepositoryMockCreateUsersForChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockCreateUsersForChatExpectation specifies expectation struct of the ChatRepository.CreateUsersForChat
type ChatRepositoryMockCreateUsersForChatExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockCreateUsersForChatParams
	paramPtrs *ChatRepositoryMockCreateUsersForChatParamPtrs
	results   *ChatRepositoryMockCreateUsersForChatResults
	Counter   uint64
}

// ChatRepositoryMockCreateUsersForChatParams contains parameters of the ChatRepository.CreateUsersForChat
type ChatRepositoryMockCreateUsersForChatParams struct {
	ctx    context.Context
	params model.CreateUsersForChatParams
}

// ChatRepositoryMockCreateUsersForChatParamPtrs contains pointers to parameters of the ChatRepository.CreateUsersForChat
type ChatRepositoryMockCreateUsersForChatParamPtrs struct {
	ctx    *context.Context
	params *model.CreateUsersForChatParams
}

// ChatRepositoryMockCreateUsersForChatResults contains results of the ChatRepository.CreateUsersForChat
type ChatRepositoryMockCreateUsersForChatResults struct {
	resp model.CreateUsersForChatResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) Optional() *mChatRepositoryMockCreateUsersForChat {
	mmCreateUsersForChat.optional = true
	return mmCreateUsersForChat
}

// Expect sets up expected params for ChatRepository.CreateUsersForChat
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) Expect(ctx context.Context, params model.CreateUsersForChatParams) *mChatRepositoryMockCreateUsersForChat {
	if mmCreateUsersForChat.mock.funcCreateUsersForChat != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by Set")
	}

	if mmCreateUsersForChat.defaultExpectation == nil {
		mmCreateUsersForChat.defaultExpectation = &ChatRepositoryMockCreateUsersForChatExpectation{}
	}

	if mmCreateUsersForChat.defaultExpectation.paramPtrs != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by ExpectParams functions")
	}

	mmCreateUsersForChat.defaultExpectation.params = &ChatRepositoryMockCreateUsersForChatParams{ctx, params}
	for _, e := range mmCreateUsersForChat.expectations {
		if minimock.Equal(e.params, mmCreateUsersForChat.defaultExpectation.params) {
			mmCreateUsersForChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUsersForChat.defaultExpectation.params)
		}
	}

	return mmCreateUsersForChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateUsersForChat
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateUsersForChat {
	if mmCreateUsersForChat.mock.funcCreateUsersForChat != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by Set")
	}

	if mmCreateUsersForChat.defaultExpectation == nil {
		mmCreateUsersForChat.defaultExpectation = &ChatRepositoryMockCreateUsersForChatExpectation{}
	}

	if mmCreateUsersForChat.defaultExpectation.params != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by Expect")
	}

	if mmCreateUsersForChat.defaultExpectation.paramPtrs == nil {
		mmCreateUsersForChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateUsersForChatParamPtrs{}
	}
	mmCreateUsersForChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateUsersForChat
}

// ExpectParamsParam2 sets up expected param params for ChatRepository.CreateUsersForChat
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) ExpectParamsParam2(params model.CreateUsersForChatParams) *mChatRepositoryMockCreateUsersForChat {
	if mmCreateUsersForChat.mock.funcCreateUsersForChat != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by Set")
	}

	if mmCreateUsersForChat.defaultExpectation == nil {
		mmCreateUsersForChat.defaultExpectation = &ChatRepositoryMockCreateUsersForChatExpectation{}
	}

	if mmCreateUsersForChat.defaultExpectation.params != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by Expect")
	}

	if mmCreateUsersForChat.defaultExpectation.paramPtrs == nil {
		mmCreateUsersForChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateUsersForChatParamPtrs{}
	}
	mmCreateUsersForChat.defaultExpectation.paramPtrs.params = &params

	return mmCreateUsersForChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateUsersForChat
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) Inspect(f func(ctx context.Context, params model.CreateUsersForChatParams)) *mChatRepositoryMockCreateUsersForChat {
	if mmCreateUsersForChat.mock.inspectFuncCreateUsersForChat != nil {
		mmCreateUsersForChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateUsersForChat")
	}

	mmCreateUsersForChat.mock.inspectFuncCreateUsersForChat = f

	return mmCreateUsersForChat
}

// Return sets up results that will be returned by ChatRepository.CreateUsersForChat
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) Return(resp model.CreateUsersForChatResponse, err error) *ChatRepositoryMock {
	if mmCreateUsersForChat.mock.funcCreateUsersForChat != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by Set")
	}

	if mmCreateUsersForChat.defaultExpectation == nil {
		mmCreateUsersForChat.defaultExpectation = &ChatRepositoryMockCreateUsersForChatExpectation{mock: mmCreateUsersForChat.mock}
	}
	mmCreateUsersForChat.defaultExpectation.results = &ChatRepositoryMockCreateUsersForChatResults{resp, err}
	return mmCreateUsersForChat.mock
}

// Set uses given function f to mock the ChatRepository.CreateUsersForChat method
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) Set(f func(ctx context.Context, params model.CreateUsersForChatParams) (resp model.CreateUsersForChatResponse, err error)) *ChatRepositoryMock {
	if mmCreateUsersForChat.defaultExpectation != nil {
		mmCreateUsersForChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateUsersForChat method")
	}

	if len(mmCreateUsersForChat.expectations) > 0 {
		mmCreateUsersForChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateUsersForChat method")
	}

	mmCreateUsersForChat.mock.funcCreateUsersForChat = f
	return mmCreateUsersForChat.mock
}

// When sets expectation for the ChatRepository.CreateUsersForChat which will trigger the result defined by the following
// Then helper
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) When(ctx context.Context, params model.CreateUsersForChatParams) *ChatRepositoryMockCreateUsersForChatExpectation {
	if mmCreateUsersForChat.mock.funcCreateUsersForChat != nil {
		mmCreateUsersForChat.mock.t.Fatalf("ChatRepositoryMock.CreateUsersForChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateUsersForChatExpectation{
		mock:   mmCreateUsersForChat.mock,
		params: &ChatRepositoryMockCreateUsersForChatParams{ctx, params},
	}
	mmCreateUsersForChat.expectations = append(mmCreateUsersForChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateUsersForChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateUsersForChatExpectation) Then(resp model.CreateUsersForChatResponse, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateUsersForChatResults{resp, err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateUsersForChat should be invoked
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) Times(n uint64) *mChatRepositoryMockCreateUsersForChat {
	if n == 0 {
		mmCreateUsersForChat.mock.t.Fatalf("Times of ChatRepositoryMock.CreateUsersForChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUsersForChat.expectedInvocations, n)
	return mmCreateUsersForChat
}

func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) invocationsDone() bool {
	if len(mmCreateUsersForChat.expectations) == 0 && mmCreateUsersForChat.defaultExpectation == nil && mmCreateUsersForChat.mock.funcCreateUsersForChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUsersForChat.mock.afterCreateUsersForChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUsersForChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUsersForChat implements repository.ChatRepository
func (mmCreateUsersForChat *ChatRepositoryMock) CreateUsersForChat(ctx context.Context, params model.CreateUsersForChatParams) (resp model.CreateUsersForChatResponse, err error) {
	mm_atomic.AddUint64(&mmCreateUsersForChat.beforeCreateUsersForChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUsersForChat.afterCreateUsersForChatCounter, 1)

	if mmCreateUsersForChat.inspectFuncCreateUsersForChat != nil {
		mmCreateUsersForChat.inspectFuncCreateUsersForChat(ctx, params)
	}

	mm_params := ChatRepositoryMockCreateUsersForChatParams{ctx, params}

	// Record call args
	mmCreateUsersForChat.CreateUsersForChatMock.mutex.Lock()
	mmCreateUsersForChat.CreateUsersForChatMock.callArgs = append(mmCreateUsersForChat.CreateUsersForChatMock.callArgs, &mm_params)
	mmCreateUsersForChat.CreateUsersForChatMock.mutex.Unlock()

	for _, e := range mmCreateUsersForChat.CreateUsersForChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmCreateUsersForChat.CreateUsersForChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUsersForChat.CreateUsersForChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUsersForChat.CreateUsersForChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUsersForChat.CreateUsersForChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateUsersForChatParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUsersForChat.t.Errorf("ChatRepositoryMock.CreateUsersForChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmCreateUsersForChat.t.Errorf("ChatRepositoryMock.CreateUsersForChat got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUsersForChat.t.Errorf("ChatRepositoryMock.CreateUsersForChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUsersForChat.CreateUsersForChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUsersForChat.t.Fatal("No results are set for the ChatRepositoryMock.CreateUsersForChat")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmCreateUsersForChat.funcCreateUsersForChat != nil {
		return mmCreateUsersForChat.funcCreateUsersForChat(ctx, params)
	}
	mmCreateUsersForChat.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateUsersForChat. %v %v", ctx, params)
	return
}

// CreateUsersForChatAfterCounter returns a count of finished ChatRepositoryMock.CreateUsersForChat invocations
func (mmCreateUsersForChat *ChatRepositoryMock) CreateUsersForChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUsersForChat.afterCreateUsersForChatCounter)
}

// CreateUsersForChatBeforeCounter returns a count of ChatRepositoryMock.CreateUsersForChat invocations
func (mmCreateUsersForChat *ChatRepositoryMock) CreateUsersForChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUsersForChat.beforeCreateUsersForChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateUsersForChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUsersForChat *mChatRepositoryMockCreateUsersForChat) Calls() []*ChatRepositoryMockCreateUsersForChatParams {
	mmCreateUsersForChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateUsersForChatParams, len(mmCreateUsersForChat.callArgs))
	copy(argCopy, mmCreateUsersForChat.callArgs)

	mmCreateUsersForChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUsersForChatDone returns true if the count of the CreateUsersForChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateUsersForChatDone() bool {
	if m.CreateUsersForChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUsersForChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUsersForChatMock.invocationsDone()
}

// MinimockCreateUsersForChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateUsersForChatInspect() {
	for _, e := range m.CreateUsersForChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateUsersForChat with params: %#v", *e.params)
		}
	}

	afterCreateUsersForChatCounter := mm_atomic.LoadUint64(&m.afterCreateUsersForChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUsersForChatMock.defaultExpectation != nil && afterCreateUsersForChatCounter < 1 {
		if m.CreateUsersForChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateUsersForChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateUsersForChat with params: %#v", *m.CreateUsersForChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUsersForChat != nil && afterCreateUsersForChatCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateUsersForChat")
	}

	if !m.CreateUsersForChatMock.invocationsDone() && afterCreateUsersForChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateUsersForChat but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUsersForChatMock.expectedInvocations), afterCreateUsersForChatCounter)
	}
}

type mChatRepositoryMockDeleteChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockDeleteChatExpectation
	expectations       []*ChatRepositoryMockDeleteChatExpectation

	callArgs []*ChatRepositoryMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockDeleteChatParams
	paramPtrs *ChatRepositoryMockDeleteChatParamPtrs
	results   *ChatRepositoryMockDeleteChatResults
	Counter   uint64
}

// ChatRepositoryMockDeleteChatParams contains parameters of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatParams struct {
	ctx    context.Context
	params model.DeleteChatParams
}

// ChatRepositoryMockDeleteChatParamPtrs contains pointers to parameters of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatParamPtrs struct {
	ctx    *context.Context
	params *model.DeleteChatParams
}

// ChatRepositoryMockDeleteChatResults contains results of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Optional() *mChatRepositoryMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Expect(ctx context.Context, params model.DeleteChatParams) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatRepositoryMockDeleteChatParams{ctx, params}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChat
}

// ExpectParamsParam2 sets up expected param params for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) ExpectParamsParam2(params model.DeleteChatParams) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.params = &params

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, params model.DeleteChatParams)) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Return(err error) *ChatRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatRepositoryMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatRepository.DeleteChat method
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Set(f func(ctx context.Context, params model.DeleteChatParams) (err error)) *ChatRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatRepositoryMockDeleteChat) When(ctx context.Context, params model.DeleteChatParams) *ChatRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatRepositoryMockDeleteChatParams{ctx, params},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockDeleteChatExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.DeleteChat should be invoked
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Times(n uint64) *mChatRepositoryMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatRepositoryMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	return mmDeleteChat
}

func (mmDeleteChat *mChatRepositoryMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements repository.ChatRepository
func (mmDeleteChat *ChatRepositoryMock) DeleteChat(ctx context.Context, params model.DeleteChatParams) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, params)
	}

	mm_params := ChatRepositoryMockDeleteChatParams{ctx, params}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockDeleteChatParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatRepositoryMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, params)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatRepositoryMock.DeleteChat. %v %v", ctx, params)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Calls() []*ChatRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat with params: %#v", *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.DeleteChat")
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.DeleteChat but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), afterDeleteChatCounter)
	}
}

type mChatRepositoryMockLinkParticipantsToChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockLinkParticipantsToChatExpectation
	expectations       []*ChatRepositoryMockLinkParticipantsToChatExpectation

	callArgs []*ChatRepositoryMockLinkParticipantsToChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockLinkParticipantsToChatExpectation specifies expectation struct of the ChatRepository.LinkParticipantsToChat
type ChatRepositoryMockLinkParticipantsToChatExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockLinkParticipantsToChatParams
	paramPtrs *ChatRepositoryMockLinkParticipantsToChatParamPtrs
	results   *ChatRepositoryMockLinkParticipantsToChatResults
	Counter   uint64
}

// ChatRepositoryMockLinkParticipantsToChatParams contains parameters of the ChatRepository.LinkParticipantsToChat
type ChatRepositoryMockLinkParticipantsToChatParams struct {
	ctx    context.Context
	params model.LinkParticipantsToChatParams
}

// ChatRepositoryMockLinkParticipantsToChatParamPtrs contains pointers to parameters of the ChatRepository.LinkParticipantsToChat
type ChatRepositoryMockLinkParticipantsToChatParamPtrs struct {
	ctx    *context.Context
	params *model.LinkParticipantsToChatParams
}

// ChatRepositoryMockLinkParticipantsToChatResults contains results of the ChatRepository.LinkParticipantsToChat
type ChatRepositoryMockLinkParticipantsToChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) Optional() *mChatRepositoryMockLinkParticipantsToChat {
	mmLinkParticipantsToChat.optional = true
	return mmLinkParticipantsToChat
}

// Expect sets up expected params for ChatRepository.LinkParticipantsToChat
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) Expect(ctx context.Context, params model.LinkParticipantsToChatParams) *mChatRepositoryMockLinkParticipantsToChat {
	if mmLinkParticipantsToChat.mock.funcLinkParticipantsToChat != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by Set")
	}

	if mmLinkParticipantsToChat.defaultExpectation == nil {
		mmLinkParticipantsToChat.defaultExpectation = &ChatRepositoryMockLinkParticipantsToChatExpectation{}
	}

	if mmLinkParticipantsToChat.defaultExpectation.paramPtrs != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by ExpectParams functions")
	}

	mmLinkParticipantsToChat.defaultExpectation.params = &ChatRepositoryMockLinkParticipantsToChatParams{ctx, params}
	for _, e := range mmLinkParticipantsToChat.expectations {
		if minimock.Equal(e.params, mmLinkParticipantsToChat.defaultExpectation.params) {
			mmLinkParticipantsToChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLinkParticipantsToChat.defaultExpectation.params)
		}
	}

	return mmLinkParticipantsToChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.LinkParticipantsToChat
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockLinkParticipantsToChat {
	if mmLinkParticipantsToChat.mock.funcLinkParticipantsToChat != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by Set")
	}

	if mmLinkParticipantsToChat.defaultExpectation == nil {
		mmLinkParticipantsToChat.defaultExpectation = &ChatRepositoryMockLinkParticipantsToChatExpectation{}
	}

	if mmLinkParticipantsToChat.defaultExpectation.params != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by Expect")
	}

	if mmLinkParticipantsToChat.defaultExpectation.paramPtrs == nil {
		mmLinkParticipantsToChat.defaultExpectation.paramPtrs = &ChatRepositoryMockLinkParticipantsToChatParamPtrs{}
	}
	mmLinkParticipantsToChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLinkParticipantsToChat
}

// ExpectParamsParam2 sets up expected param params for ChatRepository.LinkParticipantsToChat
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) ExpectParamsParam2(params model.LinkParticipantsToChatParams) *mChatRepositoryMockLinkParticipantsToChat {
	if mmLinkParticipantsToChat.mock.funcLinkParticipantsToChat != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by Set")
	}

	if mmLinkParticipantsToChat.defaultExpectation == nil {
		mmLinkParticipantsToChat.defaultExpectation = &ChatRepositoryMockLinkParticipantsToChatExpectation{}
	}

	if mmLinkParticipantsToChat.defaultExpectation.params != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by Expect")
	}

	if mmLinkParticipantsToChat.defaultExpectation.paramPtrs == nil {
		mmLinkParticipantsToChat.defaultExpectation.paramPtrs = &ChatRepositoryMockLinkParticipantsToChatParamPtrs{}
	}
	mmLinkParticipantsToChat.defaultExpectation.paramPtrs.params = &params

	return mmLinkParticipantsToChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.LinkParticipantsToChat
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) Inspect(f func(ctx context.Context, params model.LinkParticipantsToChatParams)) *mChatRepositoryMockLinkParticipantsToChat {
	if mmLinkParticipantsToChat.mock.inspectFuncLinkParticipantsToChat != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.LinkParticipantsToChat")
	}

	mmLinkParticipantsToChat.mock.inspectFuncLinkParticipantsToChat = f

	return mmLinkParticipantsToChat
}

// Return sets up results that will be returned by ChatRepository.LinkParticipantsToChat
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) Return(err error) *ChatRepositoryMock {
	if mmLinkParticipantsToChat.mock.funcLinkParticipantsToChat != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by Set")
	}

	if mmLinkParticipantsToChat.defaultExpectation == nil {
		mmLinkParticipantsToChat.defaultExpectation = &ChatRepositoryMockLinkParticipantsToChatExpectation{mock: mmLinkParticipantsToChat.mock}
	}
	mmLinkParticipantsToChat.defaultExpectation.results = &ChatRepositoryMockLinkParticipantsToChatResults{err}
	return mmLinkParticipantsToChat.mock
}

// Set uses given function f to mock the ChatRepository.LinkParticipantsToChat method
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) Set(f func(ctx context.Context, params model.LinkParticipantsToChatParams) (err error)) *ChatRepositoryMock {
	if mmLinkParticipantsToChat.defaultExpectation != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.LinkParticipantsToChat method")
	}

	if len(mmLinkParticipantsToChat.expectations) > 0 {
		mmLinkParticipantsToChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.LinkParticipantsToChat method")
	}

	mmLinkParticipantsToChat.mock.funcLinkParticipantsToChat = f
	return mmLinkParticipantsToChat.mock
}

// When sets expectation for the ChatRepository.LinkParticipantsToChat which will trigger the result defined by the following
// Then helper
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) When(ctx context.Context, params model.LinkParticipantsToChatParams) *ChatRepositoryMockLinkParticipantsToChatExpectation {
	if mmLinkParticipantsToChat.mock.funcLinkParticipantsToChat != nil {
		mmLinkParticipantsToChat.mock.t.Fatalf("ChatRepositoryMock.LinkParticipantsToChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockLinkParticipantsToChatExpectation{
		mock:   mmLinkParticipantsToChat.mock,
		params: &ChatRepositoryMockLinkParticipantsToChatParams{ctx, params},
	}
	mmLinkParticipantsToChat.expectations = append(mmLinkParticipantsToChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.LinkParticipantsToChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockLinkParticipantsToChatExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockLinkParticipantsToChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.LinkParticipantsToChat should be invoked
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) Times(n uint64) *mChatRepositoryMockLinkParticipantsToChat {
	if n == 0 {
		mmLinkParticipantsToChat.mock.t.Fatalf("Times of ChatRepositoryMock.LinkParticipantsToChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLinkParticipantsToChat.expectedInvocations, n)
	return mmLinkParticipantsToChat
}

func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) invocationsDone() bool {
	if len(mmLinkParticipantsToChat.expectations) == 0 && mmLinkParticipantsToChat.defaultExpectation == nil && mmLinkParticipantsToChat.mock.funcLinkParticipantsToChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLinkParticipantsToChat.mock.afterLinkParticipantsToChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLinkParticipantsToChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LinkParticipantsToChat implements repository.ChatRepository
func (mmLinkParticipantsToChat *ChatRepositoryMock) LinkParticipantsToChat(ctx context.Context, params model.LinkParticipantsToChatParams) (err error) {
	mm_atomic.AddUint64(&mmLinkParticipantsToChat.beforeLinkParticipantsToChatCounter, 1)
	defer mm_atomic.AddUint64(&mmLinkParticipantsToChat.afterLinkParticipantsToChatCounter, 1)

	if mmLinkParticipantsToChat.inspectFuncLinkParticipantsToChat != nil {
		mmLinkParticipantsToChat.inspectFuncLinkParticipantsToChat(ctx, params)
	}

	mm_params := ChatRepositoryMockLinkParticipantsToChatParams{ctx, params}

	// Record call args
	mmLinkParticipantsToChat.LinkParticipantsToChatMock.mutex.Lock()
	mmLinkParticipantsToChat.LinkParticipantsToChatMock.callArgs = append(mmLinkParticipantsToChat.LinkParticipantsToChatMock.callArgs, &mm_params)
	mmLinkParticipantsToChat.LinkParticipantsToChatMock.mutex.Unlock()

	for _, e := range mmLinkParticipantsToChat.LinkParticipantsToChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLinkParticipantsToChat.LinkParticipantsToChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLinkParticipantsToChat.LinkParticipantsToChatMock.defaultExpectation.Counter, 1)
		mm_want := mmLinkParticipantsToChat.LinkParticipantsToChatMock.defaultExpectation.params
		mm_want_ptrs := mmLinkParticipantsToChat.LinkParticipantsToChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockLinkParticipantsToChatParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLinkParticipantsToChat.t.Errorf("ChatRepositoryMock.LinkParticipantsToChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmLinkParticipantsToChat.t.Errorf("ChatRepositoryMock.LinkParticipantsToChat got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLinkParticipantsToChat.t.Errorf("ChatRepositoryMock.LinkParticipantsToChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLinkParticipantsToChat.LinkParticipantsToChatMock.defaultExpectation.results
		if mm_results == nil {
			mmLinkParticipantsToChat.t.Fatal("No results are set for the ChatRepositoryMock.LinkParticipantsToChat")
		}
		return (*mm_results).err
	}
	if mmLinkParticipantsToChat.funcLinkParticipantsToChat != nil {
		return mmLinkParticipantsToChat.funcLinkParticipantsToChat(ctx, params)
	}
	mmLinkParticipantsToChat.t.Fatalf("Unexpected call to ChatRepositoryMock.LinkParticipantsToChat. %v %v", ctx, params)
	return
}

// LinkParticipantsToChatAfterCounter returns a count of finished ChatRepositoryMock.LinkParticipantsToChat invocations
func (mmLinkParticipantsToChat *ChatRepositoryMock) LinkParticipantsToChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLinkParticipantsToChat.afterLinkParticipantsToChatCounter)
}

// LinkParticipantsToChatBeforeCounter returns a count of ChatRepositoryMock.LinkParticipantsToChat invocations
func (mmLinkParticipantsToChat *ChatRepositoryMock) LinkParticipantsToChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLinkParticipantsToChat.beforeLinkParticipantsToChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.LinkParticipantsToChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLinkParticipantsToChat *mChatRepositoryMockLinkParticipantsToChat) Calls() []*ChatRepositoryMockLinkParticipantsToChatParams {
	mmLinkParticipantsToChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockLinkParticipantsToChatParams, len(mmLinkParticipantsToChat.callArgs))
	copy(argCopy, mmLinkParticipantsToChat.callArgs)

	mmLinkParticipantsToChat.mutex.RUnlock()

	return argCopy
}

// MinimockLinkParticipantsToChatDone returns true if the count of the LinkParticipantsToChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockLinkParticipantsToChatDone() bool {
	if m.LinkParticipantsToChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LinkParticipantsToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LinkParticipantsToChatMock.invocationsDone()
}

// MinimockLinkParticipantsToChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockLinkParticipantsToChatInspect() {
	for _, e := range m.LinkParticipantsToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.LinkParticipantsToChat with params: %#v", *e.params)
		}
	}

	afterLinkParticipantsToChatCounter := mm_atomic.LoadUint64(&m.afterLinkParticipantsToChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LinkParticipantsToChatMock.defaultExpectation != nil && afterLinkParticipantsToChatCounter < 1 {
		if m.LinkParticipantsToChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.LinkParticipantsToChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.LinkParticipantsToChat with params: %#v", *m.LinkParticipantsToChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLinkParticipantsToChat != nil && afterLinkParticipantsToChatCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.LinkParticipantsToChat")
	}

	if !m.LinkParticipantsToChatMock.invocationsDone() && afterLinkParticipantsToChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.LinkParticipantsToChat but found %d calls",
			mm_atomic.LoadUint64(&m.LinkParticipantsToChatMock.expectedInvocations), afterLinkParticipantsToChatCounter)
	}
}

type mChatRepositoryMockSendMessage struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockSendMessageExpectation
	expectations       []*ChatRepositoryMockSendMessageExpectation

	callArgs []*ChatRepositoryMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockSendMessageExpectation specifies expectation struct of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockSendMessageParams
	paramPtrs *ChatRepositoryMockSendMessageParamPtrs
	results   *ChatRepositoryMockSendMessageResults
	Counter   uint64
}

// ChatRepositoryMockSendMessageParams contains parameters of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageParams struct {
	ctx    context.Context
	params model.SendMessageParams
}

// ChatRepositoryMockSendMessageParamPtrs contains pointers to parameters of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageParamPtrs struct {
	ctx    *context.Context
	params *model.SendMessageParams
}

// ChatRepositoryMockSendMessageResults contains results of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatRepositoryMockSendMessage) Optional() *mChatRepositoryMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Expect(ctx context.Context, params model.SendMessageParams) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatRepositoryMockSendMessageParams{ctx, params}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSendMessage
}

// ExpectParamsParam2 sets up expected param params for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectParamsParam2(params model.SendMessageParams) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.params = &params

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Inspect(f func(ctx context.Context, params model.SendMessageParams)) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Return(err error) *ChatRepositoryMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatRepositoryMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatRepository.SendMessage method
func (mmSendMessage *mChatRepositoryMockSendMessage) Set(f func(ctx context.Context, params model.SendMessageParams) (err error)) *ChatRepositoryMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatRepository.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatRepository.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatRepository.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatRepositoryMockSendMessage) When(ctx context.Context, params model.SendMessageParams) *ChatRepositoryMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatRepositoryMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatRepositoryMockSendMessageParams{ctx, params},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockSendMessageExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.SendMessage should be invoked
func (mmSendMessage *mChatRepositoryMockSendMessage) Times(n uint64) *mChatRepositoryMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatRepositoryMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	return mmSendMessage
}

func (mmSendMessage *mChatRepositoryMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements repository.ChatRepository
func (mmSendMessage *ChatRepositoryMock) SendMessage(ctx context.Context, params model.SendMessageParams) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, params)
	}

	mm_params := ChatRepositoryMockSendMessageParams{ctx, params}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockSendMessageParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatRepositoryMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, params)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatRepositoryMock.SendMessage. %v %v", ctx, params)
	return
}

// SendMessageAfterCounter returns a count of finished ChatRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatRepositoryMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatRepositoryMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatRepositoryMockSendMessage) Calls() []*ChatRepositoryMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage with params: %#v", *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.SendMessage")
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.SendMessage but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), afterSendMessageCounter)
	}
}

type mChatRepositoryMockUnlinkParticipantsFromChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockUnlinkParticipantsFromChatExpectation
	expectations       []*ChatRepositoryMockUnlinkParticipantsFromChatExpectation

	callArgs []*ChatRepositoryMockUnlinkParticipantsFromChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockUnlinkParticipantsFromChatExpectation specifies expectation struct of the ChatRepository.UnlinkParticipantsFromChat
type ChatRepositoryMockUnlinkParticipantsFromChatExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockUnlinkParticipantsFromChatParams
	paramPtrs *ChatRepositoryMockUnlinkParticipantsFromChatParamPtrs
	results   *ChatRepositoryMockUnlinkParticipantsFromChatResults
	Counter   uint64
}

// ChatRepositoryMockUnlinkParticipantsFromChatParams contains parameters of the ChatRepository.UnlinkParticipantsFromChat
type ChatRepositoryMockUnlinkParticipantsFromChatParams struct {
	ctx    context.Context
	params model.UnlinkParticipantsFromChatParams
}

// ChatRepositoryMockUnlinkParticipantsFromChatParamPtrs contains pointers to parameters of the ChatRepository.UnlinkParticipantsFromChat
type ChatRepositoryMockUnlinkParticipantsFromChatParamPtrs struct {
	ctx    *context.Context
	params *model.UnlinkParticipantsFromChatParams
}

// ChatRepositoryMockUnlinkParticipantsFromChatResults contains results of the ChatRepository.UnlinkParticipantsFromChat
type ChatRepositoryMockUnlinkParticipantsFromChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) Optional() *mChatRepositoryMockUnlinkParticipantsFromChat {
	mmUnlinkParticipantsFromChat.optional = true
	return mmUnlinkParticipantsFromChat
}

// Expect sets up expected params for ChatRepository.UnlinkParticipantsFromChat
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) Expect(ctx context.Context, params model.UnlinkParticipantsFromChatParams) *mChatRepositoryMockUnlinkParticipantsFromChat {
	if mmUnlinkParticipantsFromChat.mock.funcUnlinkParticipantsFromChat != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by Set")
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation == nil {
		mmUnlinkParticipantsFromChat.defaultExpectation = &ChatRepositoryMockUnlinkParticipantsFromChatExpectation{}
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation.paramPtrs != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by ExpectParams functions")
	}

	mmUnlinkParticipantsFromChat.defaultExpectation.params = &ChatRepositoryMockUnlinkParticipantsFromChatParams{ctx, params}
	for _, e := range mmUnlinkParticipantsFromChat.expectations {
		if minimock.Equal(e.params, mmUnlinkParticipantsFromChat.defaultExpectation.params) {
			mmUnlinkParticipantsFromChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnlinkParticipantsFromChat.defaultExpectation.params)
		}
	}

	return mmUnlinkParticipantsFromChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.UnlinkParticipantsFromChat
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockUnlinkParticipantsFromChat {
	if mmUnlinkParticipantsFromChat.mock.funcUnlinkParticipantsFromChat != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by Set")
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation == nil {
		mmUnlinkParticipantsFromChat.defaultExpectation = &ChatRepositoryMockUnlinkParticipantsFromChatExpectation{}
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation.params != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by Expect")
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation.paramPtrs == nil {
		mmUnlinkParticipantsFromChat.defaultExpectation.paramPtrs = &ChatRepositoryMockUnlinkParticipantsFromChatParamPtrs{}
	}
	mmUnlinkParticipantsFromChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUnlinkParticipantsFromChat
}

// ExpectParamsParam2 sets up expected param params for ChatRepository.UnlinkParticipantsFromChat
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) ExpectParamsParam2(params model.UnlinkParticipantsFromChatParams) *mChatRepositoryMockUnlinkParticipantsFromChat {
	if mmUnlinkParticipantsFromChat.mock.funcUnlinkParticipantsFromChat != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by Set")
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation == nil {
		mmUnlinkParticipantsFromChat.defaultExpectation = &ChatRepositoryMockUnlinkParticipantsFromChatExpectation{}
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation.params != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by Expect")
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation.paramPtrs == nil {
		mmUnlinkParticipantsFromChat.defaultExpectation.paramPtrs = &ChatRepositoryMockUnlinkParticipantsFromChatParamPtrs{}
	}
	mmUnlinkParticipantsFromChat.defaultExpectation.paramPtrs.params = &params

	return mmUnlinkParticipantsFromChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.UnlinkParticipantsFromChat
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) Inspect(f func(ctx context.Context, params model.UnlinkParticipantsFromChatParams)) *mChatRepositoryMockUnlinkParticipantsFromChat {
	if mmUnlinkParticipantsFromChat.mock.inspectFuncUnlinkParticipantsFromChat != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.UnlinkParticipantsFromChat")
	}

	mmUnlinkParticipantsFromChat.mock.inspectFuncUnlinkParticipantsFromChat = f

	return mmUnlinkParticipantsFromChat
}

// Return sets up results that will be returned by ChatRepository.UnlinkParticipantsFromChat
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) Return(err error) *ChatRepositoryMock {
	if mmUnlinkParticipantsFromChat.mock.funcUnlinkParticipantsFromChat != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by Set")
	}

	if mmUnlinkParticipantsFromChat.defaultExpectation == nil {
		mmUnlinkParticipantsFromChat.defaultExpectation = &ChatRepositoryMockUnlinkParticipantsFromChatExpectation{mock: mmUnlinkParticipantsFromChat.mock}
	}
	mmUnlinkParticipantsFromChat.defaultExpectation.results = &ChatRepositoryMockUnlinkParticipantsFromChatResults{err}
	return mmUnlinkParticipantsFromChat.mock
}

// Set uses given function f to mock the ChatRepository.UnlinkParticipantsFromChat method
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) Set(f func(ctx context.Context, params model.UnlinkParticipantsFromChatParams) (err error)) *ChatRepositoryMock {
	if mmUnlinkParticipantsFromChat.defaultExpectation != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.UnlinkParticipantsFromChat method")
	}

	if len(mmUnlinkParticipantsFromChat.expectations) > 0 {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.UnlinkParticipantsFromChat method")
	}

	mmUnlinkParticipantsFromChat.mock.funcUnlinkParticipantsFromChat = f
	return mmUnlinkParticipantsFromChat.mock
}

// When sets expectation for the ChatRepository.UnlinkParticipantsFromChat which will trigger the result defined by the following
// Then helper
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) When(ctx context.Context, params model.UnlinkParticipantsFromChatParams) *ChatRepositoryMockUnlinkParticipantsFromChatExpectation {
	if mmUnlinkParticipantsFromChat.mock.funcUnlinkParticipantsFromChat != nil {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("ChatRepositoryMock.UnlinkParticipantsFromChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockUnlinkParticipantsFromChatExpectation{
		mock:   mmUnlinkParticipantsFromChat.mock,
		params: &ChatRepositoryMockUnlinkParticipantsFromChatParams{ctx, params},
	}
	mmUnlinkParticipantsFromChat.expectations = append(mmUnlinkParticipantsFromChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.UnlinkParticipantsFromChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockUnlinkParticipantsFromChatExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockUnlinkParticipantsFromChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.UnlinkParticipantsFromChat should be invoked
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) Times(n uint64) *mChatRepositoryMockUnlinkParticipantsFromChat {
	if n == 0 {
		mmUnlinkParticipantsFromChat.mock.t.Fatalf("Times of ChatRepositoryMock.UnlinkParticipantsFromChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUnlinkParticipantsFromChat.expectedInvocations, n)
	return mmUnlinkParticipantsFromChat
}

func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) invocationsDone() bool {
	if len(mmUnlinkParticipantsFromChat.expectations) == 0 && mmUnlinkParticipantsFromChat.defaultExpectation == nil && mmUnlinkParticipantsFromChat.mock.funcUnlinkParticipantsFromChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUnlinkParticipantsFromChat.mock.afterUnlinkParticipantsFromChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUnlinkParticipantsFromChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UnlinkParticipantsFromChat implements repository.ChatRepository
func (mmUnlinkParticipantsFromChat *ChatRepositoryMock) UnlinkParticipantsFromChat(ctx context.Context, params model.UnlinkParticipantsFromChatParams) (err error) {
	mm_atomic.AddUint64(&mmUnlinkParticipantsFromChat.beforeUnlinkParticipantsFromChatCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlinkParticipantsFromChat.afterUnlinkParticipantsFromChatCounter, 1)

	if mmUnlinkParticipantsFromChat.inspectFuncUnlinkParticipantsFromChat != nil {
		mmUnlinkParticipantsFromChat.inspectFuncUnlinkParticipantsFromChat(ctx, params)
	}

	mm_params := ChatRepositoryMockUnlinkParticipantsFromChatParams{ctx, params}

	// Record call args
	mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.mutex.Lock()
	mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.callArgs = append(mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.callArgs, &mm_params)
	mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.mutex.Unlock()

	for _, e := range mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.defaultExpectation.Counter, 1)
		mm_want := mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.defaultExpectation.params
		mm_want_ptrs := mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockUnlinkParticipantsFromChatParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUnlinkParticipantsFromChat.t.Errorf("ChatRepositoryMock.UnlinkParticipantsFromChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmUnlinkParticipantsFromChat.t.Errorf("ChatRepositoryMock.UnlinkParticipantsFromChat got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnlinkParticipantsFromChat.t.Errorf("ChatRepositoryMock.UnlinkParticipantsFromChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnlinkParticipantsFromChat.UnlinkParticipantsFromChatMock.defaultExpectation.results
		if mm_results == nil {
			mmUnlinkParticipantsFromChat.t.Fatal("No results are set for the ChatRepositoryMock.UnlinkParticipantsFromChat")
		}
		return (*mm_results).err
	}
	if mmUnlinkParticipantsFromChat.funcUnlinkParticipantsFromChat != nil {
		return mmUnlinkParticipantsFromChat.funcUnlinkParticipantsFromChat(ctx, params)
	}
	mmUnlinkParticipantsFromChat.t.Fatalf("Unexpected call to ChatRepositoryMock.UnlinkParticipantsFromChat. %v %v", ctx, params)
	return
}

// UnlinkParticipantsFromChatAfterCounter returns a count of finished ChatRepositoryMock.UnlinkParticipantsFromChat invocations
func (mmUnlinkParticipantsFromChat *ChatRepositoryMock) UnlinkParticipantsFromChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlinkParticipantsFromChat.afterUnlinkParticipantsFromChatCounter)
}

// UnlinkParticipantsFromChatBeforeCounter returns a count of ChatRepositoryMock.UnlinkParticipantsFromChat invocations
func (mmUnlinkParticipantsFromChat *ChatRepositoryMock) UnlinkParticipantsFromChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlinkParticipantsFromChat.beforeUnlinkParticipantsFromChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.UnlinkParticipantsFromChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnlinkParticipantsFromChat *mChatRepositoryMockUnlinkParticipantsFromChat) Calls() []*ChatRepositoryMockUnlinkParticipantsFromChatParams {
	mmUnlinkParticipantsFromChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockUnlinkParticipantsFromChatParams, len(mmUnlinkParticipantsFromChat.callArgs))
	copy(argCopy, mmUnlinkParticipantsFromChat.callArgs)

	mmUnlinkParticipantsFromChat.mutex.RUnlock()

	return argCopy
}

// MinimockUnlinkParticipantsFromChatDone returns true if the count of the UnlinkParticipantsFromChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockUnlinkParticipantsFromChatDone() bool {
	if m.UnlinkParticipantsFromChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UnlinkParticipantsFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UnlinkParticipantsFromChatMock.invocationsDone()
}

// MinimockUnlinkParticipantsFromChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockUnlinkParticipantsFromChatInspect() {
	for _, e := range m.UnlinkParticipantsFromChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.UnlinkParticipantsFromChat with params: %#v", *e.params)
		}
	}

	afterUnlinkParticipantsFromChatCounter := mm_atomic.LoadUint64(&m.afterUnlinkParticipantsFromChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UnlinkParticipantsFromChatMock.defaultExpectation != nil && afterUnlinkParticipantsFromChatCounter < 1 {
		if m.UnlinkParticipantsFromChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.UnlinkParticipantsFromChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.UnlinkParticipantsFromChat with params: %#v", *m.UnlinkParticipantsFromChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlinkParticipantsFromChat != nil && afterUnlinkParticipantsFromChatCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.UnlinkParticipantsFromChat")
	}

	if !m.UnlinkParticipantsFromChatMock.invocationsDone() && afterUnlinkParticipantsFromChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.UnlinkParticipantsFromChat but found %d calls",
			mm_atomic.LoadUint64(&m.UnlinkParticipantsFromChatMock.expectedInvocations), afterUnlinkParticipantsFromChatCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAPILogInspect()

			m.MinimockCreateChatInspect()

			m.MinimockCreateUsersForChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockLinkParticipantsToChatInspect()

			m.MinimockSendMessageInspect()

			m.MinimockUnlinkParticipantsFromChatInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAPILogDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockCreateUsersForChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockLinkParticipantsToChatDone() &&
		m.MinimockSendMessageDone() &&
		m.MinimockUnlinkParticipantsFromChatDone()
}
